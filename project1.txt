/*http://www.ece.umd.edu/courses/enee359a/verilog_tutorial.pdf
//need to create clock generator function
always begin
#5 clock = ~clock //toggle every 5 ticks
end
*/
//taken from http://www.edaboard.com/thread145292.html

module RCA4(A,B,Ci,So,Co);
input [3:0] A,B;
input Ci;
output [3:0] So;
output Co;
wire c1,c2,c3,c4;
wire g0,g1,g2,g3;
wire p0,p1,p2,p3;

assign g0=A[0]&B[0];
assign g1=A[1]&B[1];
assign g2=A[2]&B[2];
assign g3=A[3]&B[3];

assign p0=A[0]|B[0];
assign p1=A[1]|B[1];
assign p2=A[2]|B[2];
assign p3=A[3]|B[3];

assign c1=g0|(p0&Ci);
assign c2=g1|(p1&g0)|(p1&p0&Ci);
assign c3=g2|(p2&g1)|(p2&p1&g0)|(p2&p1&p0&Ci);
assign c4=g3|(p3&g2)|(p3&p2&g1)|(p3&p2&p1&g0)|(p3&p2&p1&p0&Ci);
assign Co=c4;

assign So[0]=g0^p0^Ci;
assign So[1]=g1^p1^c1;
assign So[2]=g2^p2^c2;
assign So[3]=g3^p3^c3;
endmodule

//http://www.edaboard.com/thread145292.html
module CSA8(A,B,Ci,So,Co);
input [7:0] A,B;
input Ci;
output [7:0] So;
output Co;

wire [3:0] stemp1,stemp0;
wire c4;
wire c80,c81;

RCA4 RCA4in(A[3:0],B[3:0],Ci,So[3:0],c4);
RCA4 RCA41 (A[7:4],B[7:4],1'b1,stemp1,c81);
RCA4 RCA40 (A[7:4],B[7:4],1'b0,stemp0,c80);

assign So[7:4] = c4?stemp1:stemp0;
assign Co= c4?c81:c80;

endmodule

//http://www.edaboard.com/thread145292.html
module CSA16(A,B,Ci,So,Co);
input [15:0] A,B;
input Ci;
output [15:0] So;
output Co;

wire [7:0] stemp1,stemp0;
wire c8;
wire c160,c161;

CSA8 CSA8in(A[7:0],B[7:0],Ci,So[7:0],c8 );
CSA8 CSA81 (A[15:8],B[15:8],1'b1,stemp1,c161);
CSA8 CSA80 (A[15:8],B[15:8],1'b0,stemp0,c160);

assign So[15:8] = c8?stemp1:stemp0;
assign Co= c8?c161:c160;

endmodule

module AND16(A, B, C);
	input[15:0] A;
	input[15:0] B;
	output[15:0] C;
	reg[15:0] test = 0000000000000000;
	integer i = 0;
initial 
   begin
	for(i = 0; i < 16; i = i+1) begin
		if(A[i] & B[i]) test[i] = 1;
		else test[i] = 0;
        end
	
   end
assign C = test;
endmodule

//125 in textbook
module PCMUX(SR1OUT, add_one, next_instruction, select);

input[15:0] SR1OUT; //input from register file
input[15:0] add_one; //update PC
input[15:0] next_instruction;
input[1:0] select; //select line for the MUX\

initial
   begin
	case(select)
	00 : begin 
		     // A                              B           Ci       So      Co
		CSA16(next_instruction[15:0], 16'b0000000000000001, 0, next_instruction[15:0], 0);
	     end
	01 : CSA16(SR1OUT[15:0], 16'b0000000000000000, 0, next_instruction[15:0], 0);
	//10 : //do nothing
	endcase
   end
endmodule

module PC(MAR, MARPC, GATEPC, PCADDR);
///input clk;
input[15:0] MAR;
input MARPC;
input GATEPC;
output[15:0]PCADDR; //chosen output for PC

//reg[15:0] MAR, next_instruction;
//reg MARPC, GATEPC;

initial
   begin
	if(GATEPC == 1 && MARPC == 1) 
	CSA16(MAR[15:0], 16'b0000000000000000, 0, PCADDR[15:0], 0);

   end
endmodule

//memory & MDR
	//put contents of next_instruction in MDR
	//send MDR to IR

module memory(MAR, LDMDR, GATEMDR, MDR, j);
input [15:0] MAR;
input LDMDR;
input GATEMDR;
output reg[15:0] MDR;
reg [15:0] read_file;
reg[15:0] it = 0000000000000000;
input j;
//m[mar] = mdr //use file with instructions.
//taken from: http://www.fullchipdesign.com/verilog_file_open_close.htm
always@(it)
   begin
	casez(j)
	0: begin//MDR = mem[MAR]
   		if(it == MAR)
		begin 
			read_file = $fopen("testbench.txt", r);
		end
	   end
	//1: //write to testbench put MDR in memory
	endcase	
	it <= it + 1;
   end
initial
   begin
	if(LDMDR == 1 && GATEMDR == 1) MDR = read_file;
	$fclose(readme.txt);
   end
endmodule

//IR
module IR(LDIR, MDR, IR);
	input LDIR;
	input[15:0] MDR;
	output[15:0] IR;

   initial 
	if(LDIR == 1) CSA16(MDR[15:0], 16'b0000000000000000, 0, IR[15:0], 0);
endmodule

//Finite State Machine
module FSM(IR);
input[15:0] IR;

	reg [3:0] OPERATION;
	reg FLAG;
	reg[2:0] REGISTER1;
	reg[2:0] REGISTER2;
	reg[7:0] DATA;
	reg[6:0] ADDRESS;
always@(*)
begin
	casez(IR)
		  
		16'b00001???????????: //ADD RN, data
			begin
			assign{OPERATION, FLAG, REGISTER1, DATA} = IR;
			//  ALUK    SR2   reg1    reg2  data  addr, gatealu, answer
			ALU(2'b11, 2'b01, REGISTER1, 0, DATA, 0,1'b1, 16'b0);
			$display("ADD Rn, #data\n");
			end
		 //5432109876543210
		16'b00000???????????: //ADD RN, address
			begin
			assign{OPERATION, FLAG, REGISTER1, FLAG, ADDRESS} = IR;
			ALU(2'b11, 2'b10, REGISTER1, 0, 1'b0, ADDRESS, 1'b1, 16'b0);
			$display("ADD Rn, address\n");
			end
 		  //5432109876543210
		16'b00000????00010??: //ADD RN Ri
			begin
			assign{OPERATION, FLAG, REGISTER1, FLAG, FLAG, FLAG, FLAG, FLAG, REGISTER2} = IR;
			ALU(2'b11, 2'b00, REGISTER1, REGISTER2, 0, 0, 1'b1, 16'b0);
			$display("ADD Rn, @Ri");
			end	
		16'b00011???????????: //ANDC RN data
			begin
			$display("ANDC Rn, data\n");
			end
       endcase
end
endmodule

//ALU
module ALU(ALUK, SR2select, REGISTER1, REGISTER2, DATA, ADDRESS, GATEALU, ANSWER);
input[1:0] ALUK;
input[1:0] SR2select;//01 for data, 10 for address, 00 for register
input[15:0] REGISTER1;
input[15:0] REGISTER2;
input[7:0] DATA;
input[6:0] ADDRESS;
input GATEALU;
output[15:0] ANSWER;

initial
   begin
    if(ALUK== 2'b11 && GATEALU == 1) begin
	//ADD
	if(SR2select == 2'b01)
		//     A                 B        C   Sum          C
		CSA16(REGISTER1[15:0], DATA[7:0], 0, ANSWER[15:0], 0);
	
	if(SR2select == 2'b10)
		CSA16(REGISTER1[15:0], ADDRESS, 0, ANSWER[15:0], 0);
        if(SR2select == 2'b00)
		CSA16(REGISTER1[15:0], REGISTER2[15:0], 0, ANSWER[15:0], 0);
     end
   end
endmodule


//Register bank/file
module REGBANK(REGISTER1, REGISTER2, LDREG, SR1OUT, SR2OUT);
	input LDREG;
	input REGISTER1, REGISTER2;
	output SR1OUT, SR2OUT;
initial 
   begin
	if(LDREG == 1) begin

	end
   end

endmodule
